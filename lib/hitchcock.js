// Generated by CoffeeScript 1.6.2
(function() {
  var EventEmitter, Hitchcock, colors, fs, http, httpProxy, moment, mysql, url,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  fs = require('fs');

  http = require('http');

  httpProxy = require('http-proxy');

  colors = require('colors');

  mysql = require('mysql');

  moment = require('moment');

  url = require('url');

  module.exports = Hitchcock = (function(_super) {
    var handleRequest,
      _this = this;

    __extends(Hitchcock, _super);

    function Hitchcock(opts) {
      var _this = this;

      if (opts == null) {
        opts = {};
      }
      this.realm = opts.realm || 'TOUT';
      this.resourceOwnerMapper = opts.resourceOwnerMapper || {
        table: 'users',
        fields: ['uid']
      };
      this.dbConfig = opts.mysql || {
        database: 'hitchcock_development',
        user: 'root',
        socketPath: '/var/run/mysqld/mysqld.sock'
      };
      this.dbpool = mysql.createPool(this.dbConfig);
      this.routerConfig = opts.router || {
        '': '127.0.0.1:3000'
      };
      this.port = opts.port || 9000;
      this.proxy = new httpProxy.RoutingProxy({
        enable: {
          xforward: true
        },
        pathnameOnly: true,
        router: this.routerConfig
      });
      this.proxy.proxyTable.getProxyLocation = function(req) {
        var route, target, _i, _len, _ref, _ref1;

        if (!req || !req.headers || !req.headers.host) {
          return null;
        }
        target = req.url;
        _ref = this.routes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          route = _ref[_i];
          if (target.match(route.source.regexp)) {
            req.url = url.format(target);
            return {
              protocol: route.target.url.protocol.replace(':', ''),
              host: route.target.url.hostname,
              port: route.target.url.port || ((_ref1 = this.target.https) != null ? _ref1 : {
                443: 80
              })
            };
          }
        }
        return null;
      };
      this.server = http.createServer(function(request, response) {
        var buffer;

        buffer = httpProxy.buffer(request);
        return handleRequest({
          req: request,
          res: response
        }, {
          dbpool: _this.dbpool,
          realm: _this.realm,
          resourceOwnerMapper: _this.resourceOwnerMapper
        }, function(err, result) {
          if (!err && result) {
            return _this.proxy.proxyRequest(request, response, {
              buffer: buffer
            });
          } else {
            response.writeHead(401, {
              "Content-Type": "application/json"
            });
            response.write(JSON.stringify({
              error: 'unauthorized'
            }));
            return response.end();
          }
        });
      });
    }

    handleRequest = function(data, opts, next) {
      var queryResourceOwner, queryVerifyToken, token;

      if (opts == null) {
        opts = {};
      }
      token = data.req.headers.authorization ? data.req.headers.authorization.split(' ').reverse()[0] : url.parse(data.req.url, true).query.access_token;
      console.log(['Proxy for', data.req.url, token].join(' ').yellow);
      if (token == null) {
        return next('no_token_present');
      }
      queryVerifyToken = function(conn, token, cb) {
        var sql;

        if (typeof err !== "undefined" && err !== null) {
          console.log(err);
        }
        sql = "SELECT `oauth_access_tokens`.* FROM `oauth_access_tokens` WHERE `oauth_access_tokens`.`token` = '" + token + "' LIMIT 1";
        return conn.query(sql, function(err, rows) {
          var tokenValid;

          if (err != null) {
            return cb && cb(err, null);
          } else if (rows.length !== 1) {
            return cb && cb('token_not_found', null);
          } else {
            token = (rows || [])[0];
            tokenValid = (token.revoked_at == null) && token.expires_in && moment(token.created_at).add('seconds', token.expires_in || 0).isAfter(moment());
            return cb && cb(!tokenValid, token);
          }
        });
      };
      queryResourceOwner = function(conn, token, cb) {
        var sql, table;

        table = opts.resourceOwnerMapper.table;
        sql = "SELECT " + (['id'].concat(opts.resourceOwnerMapper.fields).join(', ')) + " FROM `" + table + "` WHERE `" + table + "`.`id` = '" + token.resource_owner_id + "' LIMIT 1";
        return conn.query(sql, function(err, user) {
          if ((err != null) || user.length !== 1) {
            return cb && cb('resource_owner_not_found');
          } else {
            user = user[0];
            return cb && cb(null, user);
          }
        });
      };
      return opts.dbpool.getConnection(function(err, conn) {
        return queryVerifyToken(conn, token, function(err, token) {
          if (err || !token) {
            conn.end();
            return next && next(true, null);
          }
          return queryResourceOwner(conn, token, function(err, resourceOwner) {
            var field, _i, _len, _ref;

            conn.end();
            resourceOwner || (resourceOwner = {});
            data.res.setHeader("X-HITCHCOCK-" + opts.realm + "-SCOPES", token.scopes);
            _ref = opts.resourceOwnerMapper.fields;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              field = _ref[_i];
              data.res.setHeader("X-HITCHCOCK-" + opts.realm + "-RESOURCE-OWNER-" + (field.toUpperCase()), resourceOwner[field]);
            }
            return next(null, true);
          });
        });
      });
    };

    Hitchcock.prototype.start = function() {
      this.server.listen(this.port, '0.0.0.0');
      return this.emit('started');
    };

    return Hitchcock;

  }).call(this, EventEmitter);

}).call(this);
